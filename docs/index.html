<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>作物病害風險儀表板（Demo）</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", Arial, sans-serif; margin: 24px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .card { border:1px solid #e5e7eb; border-radius:12px; padding:16px; box-shadow:0 1px 4px rgba(0,0,0,.05); }
    #chartWrap { padding: 8px 8px 0 8px; }
    small.muted { color:#6b7280 }
    select, button { padding:6px 10px; border-radius:8px; border:1px solid #cbd5e1; background:#fff; }
    .legend-dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:middle}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
</head>
<body>
  <h2>作物病害風險儀表板（Demo）</h2>
  <div class="row card" style="gap:16px;">
    <div>站號：<code id="stationCode">讀取中…</code></div>
    <label>時間範圍
      <select id="range">
        <option value="24h">最近 24 小時</option>
        <option value="7d" selected>最近 7 天</option>
        <option value="30d">最近 30 天</option>
      </select>
    </label>
    <span class="muted">規則：<span class="legend-dot" style="background:#34d399"></span>低風險（T&lt;20 且 RH&lt;50）、
      <span class="legend-dot" style="background:#fde047"></span>中風險（20≤T&lt;28 且 50≤RH&lt;80）、
      <span class="legend-dot" style="background:#ef4444"></span>高風險（T≥28 且 RH≥80）</span>
  </div>

  <div id="chartWrap" class="card">
    <canvas id="riskChart" height="120"></canvas>
  </div>

  <small class="muted">資料來源：CWA OpenData（由快取 JSON 提供）；此頁僅示範。</small>

<script>
(async function () {
  // DOM 取用
  const rangeSel = document.getElementById('range');               // 你原本的「時間範圍」select
  const stationCodeEl = document.getElementById('stationCode');    // 顯示站號的 span
  const controlsRow = document.querySelector('.row.card');         // 上方白色那塊容器
  const msgBox = document.getElementById('msg') || (()=>{          // 錯誤訊息容器（沒有就建一個）
    const d=document.createElement('div'); d.id='msg'; d.style.color='#dc2626';
    controlsRow.after(d); return d;
  })();

  // 動態加「站台」下拉
  const stationSel = document.createElement('select');
  stationSel.id = 'station';
  stationSel.style.marginRight = '8px';
  const citySel = document.createElement('select');  citySel.id = 'city';  citySel.style.marginRight = '8px';
  const townSel = document.createElement('select');  townSel.id = 'town';  townSel.style.marginRight = '8px';
  rangeSel.parentElement.before(citySel); rangeSel.parentElement.before(townSel); rangeSel.parentElement.before(stationSel);

  // 工具：用目前頁面當 base，組絕對路徑（避免相對路徑出錯）
  const urlFrom = p => new URL(p, location.href).toString();

  // === 時間窗 & 刻度工具（新增，約第 105 行）=========================
  const H = 3600 * 1000, D = 24 * H;  // 毫秒
  function rangeWindow(key){
    const now = new Date();
    const start = new Date(now), end = new Date(now);
    if (key === '24h'){ start.setTime(now - 24*H); end.setTime(now.getTime() + 8*H); }
    else if (key === '7d'){ start.setTime(now - 7*D); end.setTime(now.getTime() + 3*D); }
    else { start.setMonth(now.getMonth() - 1); end.setTime(now.getTime() + 7*D); } // 30d + 7d
    return {start, end, now};
  }
  function timeTicksCfg(key){
    if (key === '24h') return { unit:'hour', stepSize:1, displayFormats:{hour:'HH:mm'} };
    if (key === '7d')  return { unit:'day',  stepSize:1, displayFormats:{day:'MM-dd'} };
    return { unit:'week', stepSize:1, displayFormats:{week:'MM-dd'} }; // 30d 視週
  }
  // 依小時補到結束時間（未來段補 null，讓軸撐出去）
  function padToEnd(rows, end){
    const last = rows.length ? rows[rows.length-1].x : new Date();
    let t = new Date(last.getTime() + H);
    while (t <= end){
      rows.push({ x: new Date(t), y: null }); // null 使線段中斷；軸仍延伸
      t = new Date(t.getTime() + H);
    }
  }
// ================================================================

  // 1) 讀站台清單
  let stations = [];
  try {
    const idx = await (await fetch(urlFrom('data/index.json'), {cache:'no-store'})).json();
    stations = idx.stations || [];
  } catch (e) {
    msgBox.textContent = '載入站台清單失敗：' + e;
    return;
  }
  if (!stations.length) {
    msgBox.textContent = '目前沒有任何站台資料（請確認 Actions 是否產出 docs/data/index.json）。';
    return;
  }

  // 2) 兩層篩選 + 站台（支援 ?city= & ?town= & ?sid=）
  const usp = new URLSearchParams(location.search);
  let urlSid  = usp.get('sid');
  let urlCity = usp.get('city');
  let urlTown = usp.get('town');

  const uniq = arr => [...new Set(arr)];
  function fillCities() {
    const cities = uniq(stations.map(s => s.city)).sort();
    citySel.innerHTML = '';
    cities.forEach(c => {
      const o = document.createElement('option'); o.value = c; o.textContent = c; citySel.appendChild(o);
    });
    // 預設：URL ?city 或第一個
    citySel.value = urlCity && cities.includes(urlCity) ? urlCity : cities[0];
  }
  function fillTowns() {
    const towns = uniq(stations.filter(s => s.city === citySel.value).map(s => s.town)).sort();
    townSel.innerHTML = '';
    towns.forEach(t => {
      const o = document.createElement('option'); o.value = t; o.textContent = t; townSel.appendChild(o);
    });
    // 預設：URL ?town 或第一個
    townSel.value = (urlTown && towns.includes(urlTown)) ? urlTown : towns[0];
  }
  function fillStations() {
    const list = stations.filter(s => s.city === citySel.value && s.town === townSel.value);
    stationSel.innerHTML = '';
    list.forEach((s, i) => {
      const opt = document.createElement('option');
      opt.value = s.sid; opt.textContent = `${s.city} ${s.town} ${s.name} (${s.sid})`;
      stationSel.appendChild(opt);
    });
    // 預設：URL ?sid 或第一個
    if (urlSid && list.some(x => x.sid === urlSid)) stationSel.value = urlSid;
    else stationSel.selectedIndex = 0;
    stationCodeEl.textContent = stationSel.value;
  }

  // 初始灌入
  fillCities(); fillTowns(); fillStations();

  // 變更事件（聯動）
  citySel.addEventListener('change', () => { urlCity = citySel.value; urlTown = urlSid = null; fillTowns(); fillStations(); loadData(stationSel.value); });
  townSel.addEventListener('change', () => { urlTown = townSel.value; urlSid = null; fillStations(); loadData(stationSel.value); });


   // 3) Chart.js + 風險色帶（對應 Y=0~1，Low/Moderate/High 三帶）
  const riskBands = {
    id: 'riskBands',
    beforeDraw(chart){
      const {ctx, chartArea:{left,right,top,bottom}, scales:{x,y}} = chart;
      if (!x || !y) return;
      ctx.save();
      // 三色帶（0~1 對齊）
      const yLowTop = y.getPixelForValue(1/3);
      const yMidTop = y.getPixelForValue(2/3);
      ctx.fillStyle='rgba(52,211,153,0.65)'; ctx.fillRect(left, yLowTop, right-left, bottom - yLowTop);
      ctx.fillStyle='rgba(253,224,71,0.65)'; ctx.fillRect(left, yMidTop,  right-left, yLowTop - yMidTop);
      ctx.fillStyle='rgba(239,68,68,0.65)';  ctx.fillRect(left, top,      right-left, yMidTop - top);

      // 「現在」虛線（每次 redraw 以實時 now 定位）
      const nowX = x.getPixelForValue(new Date());
      ctx.strokeStyle='#2563eb'; ctx.setLineDash([6,6]); ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(nowX, top); ctx.lineTo(nowX, bottom); ctx.stroke();
      ctx.restore();
    }
  };

  const ctx = document.getElementById('riskChart');
  const chart = new Chart(ctx, {
    type: 'line',
    data: { datasets: [{ label:'Risk(0–1)', parsing:false, data:[], borderWidth:2, pointRadius:0, spanGaps:true, tension:.35 }]},
    options: {
      animation:false,
      scales:{
        x:{ type:'time', time:{ unit:'day' }},    // 先給 day；等會依範圍改
        y:{ min:0, max:1, ticks:{ stepSize:0.1 }, title:{display:true, text:'Risk (0.0–1.0)'} }
      },
      plugins:{ legend:{display:false},
        tooltip:{ callbacks:{ label: ctx=>{
          const d=ctx.raw;
          return `risk=${(d.y??NaN).toFixed(2)}  (T=${d.temp??'–'}°C, RH=${d.rh??'–'}%)`;
        }}}
      }
    },
    plugins:[riskBands]
  });

  // 4) 載資料 + 更新圖
  let raw = [];
  // 連續 soft score：0.0~1.0（高風險接近 1，中風險約 0.6，低風險接近 0）
  const clamp01 = x => Math.max(0, Math.min(1, x));
  const smoothstep = (x, a, b) => {           // 平滑斜坡（避免硬切）
  const t = clamp01((x - a) / (b - a));
  return t * t * (3 - 2 * t);
  };

  function softRisk(t, h){
    if (t==null || h==null) return null;
    // 高風險：T≈28↑、RH≈80↑（用平滑門檻 27~29 與 78~82）
    const highT = smoothstep(t, 27, 29);
    const highH = smoothstep(h, 78, 82);
    const high  = highT * highH;              // AND → 乘積
    // 中風險：20≤T<28 與 50≤RH<80（用 19~21、27~29 與 48~52、78~82 做「山形」）
    const midT  = smoothstep(t,19,21) * (1 - smoothstep(t,27,29));
    const midH  = smoothstep(h,48,52) * (1 - smoothstep(h,78,82));
    const moderate = midT * midH;
    // 綜合：高風險權重 1.0；中風險權重 0.6；其餘趨近 0
    const r = Math.max(high, 0.6 * moderate);
    return clamp01(r);
  }

  function sliceByRange(arr, key){
    const end = Date.now(); let start = end;
    if (key==='24h') start -= 24*3600*1000;
    else if (key==='7d') start -= 7*24*3600*1000;
    else start -= 30*24*3600*1000;
    return arr.filter(d => d.t.getTime()>=start && d.t.getTime()<=end);
  }
  async function loadData(sid){
    msgBox.textContent = '';
    stationCodeEl.textContent = sid;
    try{
      const j = await (await fetch(urlFrom(`data/${sid}.json`), {cache:'no-store'})).json();
      raw = (j.series||[]).map(d => ({ t:new Date(d.t), temp:d.temp, rh:d.rh, rain:d.rain }));
      update(rangeSel.value);
    }catch(e){
      msgBox.textContent = `載入 ${sid}.json 失敗：` + e;
    }
  }
  function update(key){
    const {start, end} = rangeWindow(key);

    // 篩選「起點到現在」的觀測資料
    const rows = raw
      .filter(d => d.t >= start && d.t <= new Date())
      .map(d => ({ x:d.t, y: softRisk(d.temp, d.rh), temp:d.temp, rh:d.rh }));

    // 補到未來結束時間（null 讓未來線段中斷，但軸延伸）
    padToEnd(rows, end);

    // 餵給圖表
    chart.data.datasets[0].data = rows;

    // X 軸視窗 & 刻度
    chart.options.scales.x.min = start;
    chart.options.scales.x.max = end;
    chart.options.scales.x.time = timeTicksCfg(key);
    chart.options.scales.x.ticks = {
      autoSkip:false,   // 全都顯示
      maxRotation:0,
      source:'auto',
      align:'center',
      // 只在整點/整日/整週顯示（Chart.js 會配合 time.unit 處理）
    };

    // 24h/7d/30d 都用相同的 Y 軸（0~1）
    chart.update('none');
  }

  // 5) 綁事件
  stationSel.addEventListener('change', ()=>loadData(stationSel.value));
  rangeSel.addEventListener('change', ()=>update(rangeSel.value));

  // 6) 初始化
  await loadData(stationSel.value);
})();
</script>

</body>
</html>
